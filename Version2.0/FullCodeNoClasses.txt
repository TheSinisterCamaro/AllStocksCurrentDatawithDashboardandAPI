import os
import sys
import tensorflow as tf
import logging

# Disable oneDNN custom operations
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'
print("TF_ENABLE_ONEDNN_OPTS:", os.environ.get('TF_ENABLE_ONEDNN_OPTS'))

# Suppress TensorFlow logs
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
tf.get_logger().setLevel(logging.ERROR)

import warnings
warnings.filterwarnings("ignore")

import tkinter as tk
from tkinter import ttk, messagebox
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from datetime import timedelta
from dash import dcc, html
import dash
import plotly.graph_objs as go
import threading
import time

# Global variables to manage the analysis thread and stop flag
analysis_thread = None
stop_flag = threading.Event()

# Function to update the "Running..." indicator
def update_running_label(running_var):
    while running_var.get() != "" and not stop_flag.is_set():
        current_text = running_var.get()
        if current_text == "Running...":
            running_var.set("Running")
        else:
            running_var.set(current_text + ".")
        root.update_idletasks()
        time.sleep(0.5)  # Adjust the speed of the animation as needed

# Function to update progress in the GUI
def update_progress(progress_var, detail_var, progress_value, detail_text):
    if not stop_flag.is_set():
        progress_var.set(progress_value)
        detail_var.set(detail_text)
        root.update_idletasks()

# Function to check if the process should be stopped
def check_stop():
    if stop_flag.is_set():
        raise SystemExit("Analysis stopped by the user.")

# Function to run the full analysis and update progress
def run_full_analysis_gui(ticker, progress_var, detail_var):
    try:
        date_time_suffix = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
        base_output_dir = r"C:\File\Path|Here" # Add file path to store results
        output_dir = create_directory(base_output_dir, ticker, date_time_suffix)

        # Update progress
        update_progress(progress_var, detail_var, 10, "Collecting and cleaning data...")
        ubs_data = collect_and_clean_data(ticker, "2010-01-01", interval='1d')
        check_stop()

        # Prepare data for LSTM
        update_progress(progress_var, detail_var, 30, "Preparing data for LSTM...")
        X_train, y_train, scaler = prepare_lstm_data_with_features(ubs_data)
        check_stop()

        # Train model
        update_progress(progress_var, detail_var, 50, "Training LSTM model...")
        lstm_model = train_lstm_model(X_train, y_train, output_dir, ticker)
        check_stop()

        # Plot and save graphs
        update_progress(progress_var, detail_var, 70, "Plotting and saving graphs...")
        plot_and_save_graphs(ubs_data, output_dir, ticker)
        check_stop()

        # Predict future prices
        update_progress(progress_var, detail_var, 90, "Predicting future prices...")
        future_predictions = predict_future_prices_lstm(lstm_model, ubs_data, scaler, output_dir, ticker, future_days=365)
        check_stop()

        # Finalize
        update_progress(progress_var, detail_var, 100, f"Analysis complete! View results at: {output_dir}\nVisit the dashboard at http://127.0.0.1:8050/")
        
        # Start dashboard in a separate process to avoid blocking
        start_dashboard(ubs_data, future_predictions, ticker)
    except SystemExit as e:
        print(f"Analysis stopped: {e}")
        os._exit(0)  # Forcefully terminate the process
    except Exception as e:
        print(f"An error occurred: {e}")
        os._exit(1)  # Terminate the process due to an error

# Function to handle running analysis from the GUI
def on_run_analysis(stock_ticker, progress_var, detail_var, running_var):
    global analysis_thread, stop_flag
    stop_flag.clear()  # Clear the stop flag at the start
    running_var.set("Running...")
    threading.Thread(target=update_running_label, args=(running_var,)).start()

    # Run analysis in a separate thread
    analysis_thread = threading.Thread(target=run_full_analysis_gui, args=(stock_ticker, progress_var, detail_var))
    analysis_thread.start()

# Function to handle the End button click
def on_end_program():
    global analysis_thread, stop_flag
    stop_flag.set()  # Signal the analysis thread to stop
    if analysis_thread is not None and analysis_thread.is_alive():
        analysis_thread.join(timeout=5)  # Wait for the thread to stop
    root.destroy()  # Properly close the GUI
    os._exit(0)  # Forcefully terminate the process

# Function to create a directory with a date-time suffix
def create_directory(base_path, stock_name, suffix):
    directory_path = os.path.join(base_path, f"{stock_name}_results_{suffix}")
    if not os.path.exists(directory_path):
        os.makedirs(directory_path)
    return directory_path

# Function to collect and clean data
def collect_and_clean_data(ticker, start_date, interval='1d'):
    check_stop()  # Check if stop flag is set
    end_date = dt.datetime.now()
    data = yf.download(ticker, start=start_date, end=end_date, interval=interval)
    if data.isnull().values.any():
        print("Missing values detected. Applying linear interpolation...")
        data.interpolate(method='linear', inplace=True)
    return data

# Function to prepare LSTM data
def prepare_lstm_data_with_features(data, look_back=90):
    check_stop()  # Check if stop flag is set
    data['MA_20'] = data['Close'].rolling(window=20).mean()
    data['MA_50'] = data['Close'].rolling(window=50).mean()
    data['RSI'] = data['Close'].rolling(window=14).apply(
        lambda x: 100 - (100 / (1 + (x.diff().clip(lower=0).sum() / abs(x.diff().clip(upper=0).sum()))))
    )
    data['Volatility'] = data['Close'].rolling(window=20).std()
    data.dropna(inplace=True)
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(data)
    X, y = [], []
    for i in range(look_back, len(scaled_data)):
        X.append(scaled_data[i-look_back:i])
        y.append(scaled_data[i, 0])
    X, y = np.array(X), np.array(y)
    return X, y, scaler

# Function to train the LSTM model with optimizations
def train_lstm_model(X_train, y_train, output_dir, stock_name):
    check_stop()  # Check if stop flag is set
    model = Sequential()

    # Reduced LSTM units and layers for faster performance
    model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
    model.add(Dropout(0.2))
    model.add(LSTM(units=50))
    model.add(Dropout(0.2))
    model.add(Dense(1))

    model.compile(optimizer='adam', loss='mean_squared_error')

    # Adjusted batch size and reduced epochs for faster training
    model.fit(X_train, y_train, epochs=25, batch_size=64)
    
    model_path = os.path.join(output_dir, f"{stock_name}_lstm_model.h5")
    model.save(model_path)
    print(f"LSTM model saved to {model_path}")
    return model

# Function to plot and save graphs
def plot_and_save_graphs(data, output_dir, stock_name):
    check_stop()  # Check if stop flag is set
    plt.figure(figsize=(10, 6))
    plt.plot(data['Close'], label='Close Price')
    plt.plot(data['MA_20'], label='20-Day Moving Average')
    plt.plot(data['MA_50'], label='50-Day Moving Average')
    plt.title(f'{stock_name} Historical Prices with Moving Averages')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.savefig(os.path.join(output_dir, f"{stock_name}_historical_prices_moving_averages.png"))
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(data['RSI'], label='RSI')
    plt.axhline(30, linestyle='--', color='red')
    plt.axhline(70, linestyle='--', color='red')
    plt.title(f'{stock_name} Relative Strength Index (RSI)')
    plt.xlabel('Date')
    plt.ylabel('RSI')
    plt.legend()
    plt.savefig(os.path.join(output_dir, f"{stock_name}_RSI.png"))
    plt.close()

    plt.figure(figsize=(10, 6))
    plt.plot(data['Volatility'], label='Volatility')
    plt.title(f'{stock_name} Volatility')
    plt.xlabel('Date')
    plt.ylabel('Volatility')
    plt.legend()
    plt.savefig(os.path.join(output_dir, f"{stock_name}_Volatility.png"))
    plt.close()

# Function to predict future prices
def predict_future_prices_lstm(model, data, scaler, output_dir, stock_name, look_back=90, future_days=365):
    check_stop()  # Check if stop flag is set
    last_data = data[-look_back:].values
    scaled_last_data = scaler.transform(last_data)
    future_inputs = np.reshape(scaled_last_data, (1, look_back, scaled_last_data.shape[1]))
    predictions = []
    for _ in range(future_days):
        check_stop()  # Check if stop flag is set within the loop
        pred = model.predict(future_inputs)
        predictions.append(pred[0, 0])
        future_inputs = np.roll(future_inputs, -1, axis=1)
        future_inputs[0, -1, 0] = pred
    closing_price_predictions = np.array(predictions).reshape(-1, 1)
    dummy_scaled_data = np.zeros((closing_price_predictions.shape[0], scaler.n_features_in_))
    dummy_scaled_data[:, 0] = closing_price_predictions.flatten()
    inverse_transformed_predictions = scaler.inverse_transform(dummy_scaled_data)[:, 0]
    future_dates = [data.index[-1] + timedelta(days=i) for i in range(1, future_days + 1)]
    forecast_series = pd.Series(inverse_transformed_predictions.flatten(), index=future_dates)
    forecast_series.to_csv(os.path.join(output_dir, f"{stock_name}_lstm_future_predictions.csv"))
    print(f"Future predictions saved to {output_dir}")
    return forecast_series

# Function to create a dashboard
def create_dashboard(data, predictions, stock_name):
    app = dash.Dash(__name__)
    app.layout = html.Div(children=[
        html.H1(children=f'{stock_name} Stock Price Prediction Dashboard'),
        dcc.Graph(
            id='historical-prices',
            figure={
                'data': [
                    go.Scatter(x=data.index, y=data['Close'], mode='lines', name='Historical Close Price'),
                    go.Scatter(x=predictions.index, y=predictions, mode='lines', name='Predicted Close Price')
                ],
                'layout': go.Layout(title=f'{stock_name} Historical and Predicted Prices')
            }
        ),
        dcc.Graph(
            id='rsi-plot',
            figure={
                'data': [
                    go.Scatter(x=data.index, y=data['RSI'], mode='lines', name='RSI')
                ],
                'layout': go.Layout(title='RSI (Relative Strength Index)')
            }
        ),
        dcc.Graph(
            id='volatility-plot',
            figure={
                'data': [
                    go.Scatter(x=data.index, y=data['Volatility'], mode='lines', name='Volatility')
                ],
                'layout': go.Layout(title='Volatility')
            }
        ),
    ])
    app.run_server(debug=False, use_reloader=False)

def start_dashboard(data, predictions, stock_name):
    threading.Thread(target=create_dashboard, args=(data, predictions, stock_name)).start()

# GUI Setup with "Running..." indicator and End Button
def setup_gui():
    global root
    root = tk.Tk()
    root.title("Stock Analysis Tool")

    # Stock Ticker Label and Entry
    tk.Label(root, text="Enter Stock Ticker:").grid(row=0, column=0, padx=10, pady=10)
    ticker_entry = tk.Entry(root)
    ticker_entry.grid(row=0, column=1, padx=10, pady=10)

    # Progress Bar
    progress_var = tk.DoubleVar()
    progress_bar = ttk.Progressbar(root, variable=progress_var, maximum=100)
    progress_bar.grid(row=1, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

    # Detail Text
    detail_var = tk.StringVar()
    detail_label = tk.Label(root, textvariable=detail_var, wraplength=400)
    detail_label.grid(row=2, column=0, columnspan=2, padx=10, pady=10)

    # Running Indicator
    running_var = tk.StringVar()
    running_label = tk.Label(root, textvariable=running_var)
    running_label.grid(row=3, column=0, columnspan=2, padx=10, pady=10)

    # Run Analysis Button
    def on_button_click():
        stock_ticker = ticker_entry.get().strip().upper()
        if stock_ticker:
            on_run_analysis(stock_ticker, progress_var, detail_var, running_var)

    run_button = tk.Button(root, text="Run Analysis", command=on_button_click)
    run_button.grid(row=4, column=0, columnspan=2, padx=10, pady=10)

    # End Button
    end_button = tk.Button(root, text="End", command=on_end_program)
    end_button.grid(row=5, column=0, columnspan=2, padx=10, pady=10)

    # Start the GUI event loop
    root.mainloop()

# Start the GUI
if __name__ == "__main__":
    setup_gui()
